# TCP编程-Client

## 课程导入
我们从今天开始，正式进入网络编程的领域。对于网络大家应该都非常熟悉了。我们日常使用的大部分程序，我们获取的大部分信息，都依赖网络。比如：
* 微信：让我们可以和另一个人发消息、通话、看对方发的动态；
* bilibili视频网站：我们可以在网站上观看最新的动画片和电影；
* 高德地图：我们在进入一个陌生环境时，可以通过网络下载该地区的电子地图，并且通过网络获取自己的位置，实现定位和导航。

听上去这些依赖网络的应用程序都很复杂，但本质上，他们都用到了一些相同或者相近的技术。这些技术从本质上，都在帮助我们解决一个最基本的问题：**与一台远程计算机连接并且交换数据**。这就是网络程序最本质需要解决的问题。

## 网络基础知识
为了能够看懂并且能够会用网络程序，我们需要至少知道一点点概念。我们的课堂试图用最简单的方式做一个基本的解释。因为做了很多简化，所以有些表述是不严谨的。这一点同学们在查阅参考资料和未来自学时要了解到。

刚才我们说了， 网络程序最基本的功能是与一台远程计算机连接并且交换数据。那么，有两个关键点必须解决：
1. 找到目标；
2. 和目标进行通信；

### 找到目标
先说第一个关键点。
在人类世界中，你要想找到一个人，最基本的信息是什么？**名字和地址**！这是找一个人最重要的信息。在网络世界，同样如此。网络世界中的计算机，都有自己的“名字和地址”，它们就是IP地址，类似于下面这样：
```bash
202.108.22.5
```
IP地址由4组数字组成，每组数字从0到255。也就是地址从：
```bash
二进制：0.0.0.0 - 11111111.11111111.11111111.11111111
十进制：0.0.0.0 - 255.255.255.255
十六进制：0.0.0.0 - FF.FF.FF.FF
```

除了一部分数字组合被保留下来挪作他用之外，绝大部分的数字组合就代表一台服务器。
它既是服务器的名称，也是服务器的地址，因为，一台计算机通过上面的IP地址，就可以在网络中唯一的找到对应的目标。这个寻找目标的过程很形象的称之为“寻址”（Addressing），而寻址的操作是一个称之为**IP协议**的通信协议完成的。
IP协议根据数据包中要求的目标地址，选择合适的传送路径，将数据传送到目的地点（其中，选择合适路径的过程，称之为“路由”（Routing））。
听上去，IP协议特别像**快递员**。接受一个包裹，查看目标地址后，选择最合适的线路，将包裹投送到目标。
大家可能会有两点疑惑：
* 疑惑1：一共四组数字，每组才256个数字，全世界那么多计算机、手机、平板电脑。够用么？
* 疑惑2：我们平时使用电脑手机，也并没有经常使用这种**IP地址**啊？

针对疑惑1，大家的判断是对的。当前的IP地址是早前计算机还没那么多的时候做的定义，理论上能够提供的地址范围有限（大家算算一共可以提供多少个不同地址）。而当今时代，计算设备层出不穷，确实地址不够用了。怎么办呢？大家猜猜？

【学生提问】怎么解决IP地址不够用的问题呢？

大家可能猜到了，解决IP地址不够用的问题，就是扩大IP地址的数字范围。地址扩大为128位，通常写成8组，每组4个十六进制数：
```bash
0.0.0.0 - FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF
```
这种地址是在iP协议的第六版中定义的，因此称为，IPv6地址。之前的，是在第四版中定义的，对应的称之为IPv4。下面是一个典型的IPv6地址：
```bash
2400:da00:0000:0000:0000:0dbf:0000:1000
```
以上的地址能够表示大量的地址了，但是变得很长，行业内有一种公认的简写方法，有兴趣的同学可以查查看。
大家有兴趣的话，还可以算算，IPv6总共能够表示多少地址？有一种说法是，**IPv6可以给地球上每一粒沙子都分配一个IP地址**。

第二个疑惑，依然是个非常好的问题，为什么我们平时没有用IP地址呢？是因为像上面写到的地址202.108.22.5太难记了，因此人们发明了一种名称体系来表示IP地址并设计了一套对应关系，例如：
```bash
202.108.22.5对应的名称是：baidu.com
```
大家看，用了名字，是不是就好记多了？
这种名称体系，叫做**域名（Domain Name）**。
有了域名，我们就可以轻松的知道服务器的地址，有很多域名大家可能都听说过，大概也知道不同的域名后缀代表了不同的含义，例如：
```bash
gov.cn （中国的）
mit.edu（教育的）
google.com（企业的）
```
有时候，通过域名的前缀，我们还能知道这个域名是提供什么服务的：
```bash
music.qq.com (QQ的音乐服务)
```
域名有很多有意思的细节，我们以后用到的时候再讲。
全球有很多服务器专门用来帮助用户将域名“翻译”成IP地址，这种服务称之为“域名系统”（Domain Name System，DNS），大家知道就好了，以后我们还会说这个。

有了地址，就可以准确投递信息了么？不一定。因为一台计算机上，可能有多个程序都需要通信，那么，一条消息过来，应该是那个程序来处理呢？
例如，我们家收到一个寄送到“3号楼901”的包裹，这是我们家的地址没错，但因为我们家有好几口人，所以我们必须去包裹上看名称，来确认到底是谁的。
针对这种情况，在IP地址后面经常可以看到这种形式：
```bash
192.168.0.1:8080
```
冒号后面的数字称之为”**端口号（Port Number）**”。在同一个IP地址下，通过不同的端口号，数据包就能找到对应的处理程序了。
其中，我们所访问的大部分网站，默认都使用了80端口。因此，我们使用的浏览器，在输入网址或者IP地址时，如果是默认的80端口，就可以不用输入，也就是说，下面两种方式是等价的：
```bash
baidu.com 等价于 baidu.com:80
```
但如果程序使用了其它端口，则必须在地址栏中写清楚。否则，寄给你的圣诞礼物可能就被爸爸妈妈拿走了😄。


### 和目标进行通信
IP协议可以帮助我们将数据发送到对应的地址。那么，和目标通信的问题解决了么？设想一下，你现在和一个朋友彼此知道通信地址，希望互发消息聊天。但你这位朋友是新西兰的毛利族人，平时使用毛利语。而你自己使用汉语。这种情况如何沟通呢？办法有三种：
1. 你学会毛利语；
2. 朋友学会汉语；
3. 大家共同使用一种第三方语言，比如英语。

计算机和计算机之间，要进行顺畅的通信，也必须使用一种大家都能明白、彼此共同遵守的“语言”。我们称之为**通信协议（Protocol）**。其中，最重要的一种通信协议就是TCP：传输控制协议（Transmission Control Protocol）。大家都遵守TCP协议的情况下，可以稳定可靠的在计算机之间传输数据。
TCP协议的运行可划分为三个阶段：
* 连接创建(connection establishment)；
* 数据传送（data transfer）；
* 连接终止（connection termination）

这个运行过程，大家有没有联想起什么？
大家回忆一下将数据写入文件的操作步骤：
* 打开一个文件（Open）；
* 写入文件（Write）;
* 关闭文件（Close）；

网络传输数据的过程，和文件读写的过程非常相似。大家记住这一点，等会看程序就容易很多了。


## Socket
程序使用TCP协议和IP协议传输数据，使用的是一种称之为”**套接字（Socket）**”的工具。应用程序，可以使用Socket完成数据的发送和接收。
Socket，TCP，IP之间的关系是这样的：

![socket,TCP,IP][image-1]

几乎所有的操作系统和编程语言，都提供了对上述内容的支持。也就是说，在某种编程语言中，找到对应的Socket支持，创建一个Socket，然后按照上面说的三个步骤，就可以完成数据包的传送。Socket的大致工作流程如下图所示：
![socket1.png][image-2]

我们可以看到，Socket的操作步骤分成了服务端（Server）和客户端(Client)。我们在这里做个约定，被动接收数据并根据接收到的数据进行反应的，我们称之为“服务端”，主动发送数据并根据获取的数据进行反应的，我们称之为“客户端”。
很显然，很多时候，一些程序可能既是服务端，也是客户端。
今天，我们先来给大家讲解一下客户端怎么做，下节课我们再讲服务端。这样，我们就可以成套的开发一个通信系统了。

## 客户端发送和接收数据
Python中的Socket非常容易使用。我们先看看今天的Demo程序：
```python
# 导入socket库:
import socket

# 创建一个socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 建立连接:
s.connect(('news.baidu.com', 80))
# 发送数据:
s.send(b'GET / HTTP/1.1\r\nHost: news.baidu.com\r\nConnection: close\r\n\r\n')
# 接收数据:
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)
# 关闭连接:
s.close()
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode('utf-8'))
# 把接收的数据写入文件:
with open('baidu.html', 'wb') as f:
    f.write(html)

# end

```

下面我们详细讲解一下：
socket模块已经内置，用起来很简单：
```python
import socket
```

步骤一：创建Socket：
```python
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

查看API，创建Socket的参数格式为：
```python
socket.socket([family[, type[, proto]]])
```

**family**: 套接字名称协议，可以使用`AF_UNIX`   或者 `AF_INET`,
前者是一种UNIX命名方式，在网络中，用一个字符串标明地址。我们常用的是后者，使用IP+端口标明地址。实际上，在Python新版本中，还支持参数`AF_INET6`，大家猜猜看，这个参数是干啥的？ 

**type**: 套接字类型可以根据是面向连接的还是非连接分为 `SOCK_STREAM  ` 或者 `SOCK_DGRAM ` 。我们一般用面向连接的系统。

**protocol**: 一般不填默认为0.


步骤二：建立连接，这里的80端口不能节省：
```python
s.connect(('news.baidu.com', 80))
```

步骤三：发送数据：
```python
s.send(b'GET / HTTP/1.1\r\nHost: news.baidu.com\r\nConnection: close\r\n\r\n')
```
注意一下，通过socket发送的数据，需要byte格式，而非字符串。byte格式和字符串格式的转换请大家查阅一下之前学过的，或者在网上搜索。
另外，发送的数据实际上格式是这样的：
```python
GET / HTTP/1.1
Host: news.baidu.com
Connection: close


```
注意，最后包含两个空行。
这是一个典型的HTTP协议的头（head），具体的格式稍后再说。HTTP 协议是我们最常使用的应用型协议，我们浏览网站大部分都是用了HTTP协议。通过发送这样的请求，可以得到返回数据：
```python
# 接收数据:
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)
```
Buffer是一个list，每接收到1K字节的数据，就存入到buffer中去，直到没有数据退出循环为止。最后，用字符串的join方法将list拼接成byte数据data。
上面的写法很经典，大家多看看，以后经常会用类似的写法。等熟练了，大家还可以尝试其它写法。

步骤四：关闭连接：
```python
# 关闭连接:
s.close()
```

最后，应该吧接收到的数据打印出来或者保存起来，这里很有意思，我们看看：
```python
header, html = data.split(b'\r\n\r\n', 1)
```
这句的意思是，将HTTP数据包拆分成包头和内容。HTTP的包头，刚才我们在发送数据这里看到了一个，返回数据是这样的：
```python
HTTP/1.1 200 OK
Content-Type: text/html;charset=utf-8
Date: Mon, 16 Dec 2019 09:08:30 GMT
P3p: CP=" OTI DSP COR IVA OUR IND COM "
Server: Apache
Set-Cookie: BAIDUID=ACE1C68022832DE7D1C2D0982B36D04E:FG=1; expires=Tue, 15-Dec-20 09:08:30 GMT; max-age=31536000; path=/; domain=.baidu.com; version=1
Tracecode: 05109308830392113674121617
Tracecode: 05109050282888781066121617
Vary: Accept-Encoding
Vary: Accept-Encoding
X-Bd-Api: news_index
X-Bd-Status: 200
Connection: close
Transfer-Encoding: chunked
```
具体内容可以不用太在意，我们以后有机会再讲。但从总体上，综合我们见过的两个包头来说，HTTP的协议看上去应该是这样的：
```python
GET / HTTP/1.1
关键字: 数值 [CRLF]
关键字: 数值 [CRLF]
******
关键字: 数值 [CRLF]
[CRLF]
```
和：
```python
HTTP/1.1 200 OK
关键字: 数值 [CRLF]
关键字: 数值 [CRLF]
******
关键字: 数值 [CRLF]
[CRLF]
数据包
```

这里CR代表“回车”（Carriage-Return），对应字符串里面的`“\r”`，LF代表“换行”（Line-Feed）对应字符串里面的`“\n”`。
简单来说，HTTP协议的格式，第一行是类型，名称和返回值（我们以后讲）。
第二行开始，每行一个关键字+数值的形式，用CRLF结尾。以此类推，所有的包头结束后，用一个空行（CRLF）隔开，后面是数据。
因此，上面的代码用 `split(b'\r\n\r\n', 1)`  实际上是分隔了包头header和数据data。
包头直接打印出来了：
```python
print(header.decode('utf-8'))
```
因为header是byte类型，用utf-8格式转化为字符串。
内容则用如下的方式写入文件：
```python
# 把接收的数据写入文件:
with open('baidu.html', 'wb') as f:
    f.write(html)
```
这里的**with**和**as**关键字我们以前没用过。这里讲解一下。

我们回忆一下之前打开一个文件的方法：
```python
file = open("/tmp/foo.txt")
data = file.read()
file.close()
```
但是这样写，如果文件不存在或者忘了关闭文件，就可能出错。所以，更安全的做法是这样的：
```python
file = open("/tmp/foo.txt")
try:
    data = file.read()
finally:
    file.close()
```
大家可以尝试一下这种写法，慢慢体会一下，它是一种安全的、不会让程序崩溃的写法。
但是这样写，比较费力繁琐。Python提供了一种很简洁的写法：
```python
with open("/tmp/foo.txt") as file:
    data = file.read()
```

回过来，大家看看上面的代码：
```python
# 把接收的数据写入文件:
with open('baidu.html', 'wb') as f:
    f.write(html)

等价于：


f = open('baidu.html', 'wb') 
try:
	f.write(html)
finally:
	f.close()
```

这种用法后面会经常看到，大家体会一下。可以仿照着写试试看。
上面就是完整的代码分析，我们看看结果是什么：一个完整的页面被存在baidu.html文件中了，你可以用浏览器打开看看。

实际上，这段简单的代码实现了一个最简单的功能，用命令向百度新闻网站请求数据，将新闻从百度抓取到我们的计算机上并保存。这个简单的功能，其实也是任何浏览器最重要的核心功能之一。

## 作业
请仔细阅读今天老师演示的代码，自己写一遍。尝试修改成其它网址，看看下载的数据。

[image-1]:	socket2.jpg
[image-2]:	socket1.png